<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Power-Chess: Chaos Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore-compat.js"></script>
    <style>
        :root {
            --board-light: #ebecd0;
            --board-dark: #779556;
        }

        body {
            overscroll-behavior: none;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            background: #0f172a;
        }

        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            width: 100%;
            max-width: 480px;
            aspect-ratio: 1;
            border: 4px solid #1e293b;
            user-select: none;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 20px 25px -5px rgb(0 0 0 / 0.5);
        }

        .square {
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: clamp(1.2rem, 8vw, 2.5rem);
            cursor: pointer;
            position: relative;
        }

        .square.light { background-color: var(--board-light); }
        .square.dark { background-color: var(--board-dark); }
        .square.selected { background-color: #f5f682 !important; }
        .square.valid-move::after {
            content: '';
            width: 25%;
            height: 25%;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 50%;
        }

        .piece {
            z-index: 10;
            transition: transform 0.15s ease-out;
            line-height: 1;
        }

        .mana-bar {
            height: 6px;
            background: #334155;
            border-radius: 10px;
            overflow: hidden;
            width: 100%;
        }

        .power-btn {
            transition: all 0.2s;
            cursor: pointer;
            border: 2px solid transparent;
        }

        .power-btn:active { transform: scale(0.95); }
        .power-btn.active { border-color: #fbbf24; background: #334155; }
        .power-btn.disabled { opacity: 0.3; filter: grayscale(1); cursor: not-allowed; }

        #toast {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
    </style>
</head>
<body class="text-white min-h-screen flex flex-col items-center">

    <div id="toast" class="bg-blue-600 px-6 py-3 rounded-full shadow-2xl font-bold text-sm"></div>

    <div class="w-full max-w-lg flex flex-col items-center p-4 gap-4">
        
        <!-- Header & Mode Selection -->
        <div class="w-full flex justify-between items-center mb-2">
            <h1 class="text-xl font-black tracking-tighter text-blue-400">POWER-CHESS</h1>
            <div class="flex gap-2">
                <button id="mode-ai" onclick="setMode('ai')" class="px-3 py-1 text-[10px] font-bold bg-purple-600 rounded uppercase">AI Mode</button>
                <button id="mode-pvp" onclick="setMode('pvp')" class="px-3 py-1 text-[10px] font-bold bg-blue-600 rounded uppercase">Multiplayer</button>
            </div>
        </div>

        <!-- Opponent Status -->
        <div class="w-full flex items-center justify-between bg-gray-800/50 p-3 rounded-xl border border-white/5">
            <div class="flex items-center gap-3">
                <div class="w-10 h-10 bg-red-500 rounded-full flex items-center justify-center text-xl" id="opp-icon">üë§</div>
                <div>
                    <p id="opp-name" class="text-xs font-bold text-gray-400">Opponent</p>
                    <div class="mana-bar mt-1 w-32"><div id="mana-black-fill" class="h-full bg-red-500 w-1/2 transition-all"></div></div>
                </div>
            </div>
            <div id="opp-mana-text" class="text-xs font-mono">25 MP</div>
        </div>

        <!-- Game Board -->
        <div id="turn-indicator" class="text-[10px] font-black uppercase tracking-[0.2em] py-1 px-4 bg-white text-black rounded-full">
            White's Turn
        </div>
        <div id="board" class="chess-board"></div>

        <!-- Player Status -->
        <div class="w-full flex items-center justify-between bg-gray-800/50 p-3 rounded-xl border border-white/5">
            <div class="flex items-center gap-3">
                <div class="w-10 h-10 bg-blue-500 rounded-full flex items-center justify-center text-xl">üë§</div>
                <div>
                    <p class="text-xs font-bold text-gray-400">You (White)</p>
                    <div class="mana-bar mt-1 w-32"><div id="mana-white-fill" class="h-full bg-blue-500 w-1/2 transition-all"></div></div>
                </div>
            </div>
            <div id="player-mana-text" class="text-xs font-mono">25 MP</div>
        </div>

        <!-- Power Bar -->
        <div class="w-full grid grid-cols-3 gap-2 mt-2">
            <button onclick="activatePower('teleport')" id="btn-teleport" class="power-btn bg-gray-800 p-2 rounded-lg flex flex-col items-center">
                <span class="text-lg">üåÄ</span>
                <span class="text-[9px] font-bold">TELEPORT (20)</span>
            </button>
            <button onclick="activatePower('freeze')" id="btn-freeze" class="power-btn bg-gray-800 p-2 rounded-lg flex flex-col items-center">
                <span class="text-lg">‚ùÑÔ∏è</span>
                <span class="text-[9px] font-bold">FREEZE (15)</span>
            </button>
            <button onclick="activatePower('spawn')" id="btn-spawn" class="power-btn bg-gray-800 p-2 rounded-lg flex flex-col items-center">
                <span class="text-lg">üõ°Ô∏è</span>
                <span class="text-[9px] font-bold">QUEEN (40)</span>
            </button>
        </div>

        <div id="multiplayer-controls" class="hidden w-full bg-blue-900/20 p-3 rounded-lg border border-blue-500/30 text-center">
            <p class="text-[10px] mb-2 uppercase font-bold text-blue-300">Share this link to play:</p>
            <input id="game-url" readonly class="w-full bg-black/40 text-[10px] p-2 rounded mb-2 text-blue-200 outline-none" type="text">
            <button onclick="copyURL()" class="text-[10px] font-bold bg-blue-600 px-4 py-1 rounded">COPY LINK</button>
        </div>

    </div>

    <script>
        const apiKey = ""; // Provided by env
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'power-chess-v2';
        const firebaseConfig = JSON.parse(__firebase_config);
        
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
        const auth = firebase.auth();

        const PIECES = {
            'white': { 'p': '‚ôô', 'r': '‚ôñ', 'n': '‚ôò', 'b': '‚ôó', 'q': '‚ôï', 'k': '‚ôî' },
            'black': { 'p': '‚ôü', 'r': '‚ôú', 'n': '‚ôû', 'b': '‚ôù', 'q': '‚ôõ', 'k': '‚ôö' }
        };

        let state = {
            gameId: new URLSearchParams(window.location.search).get('game') || 'local',
            mode: 'ai', // 'ai' or 'pvp'
            myColor: 'white',
            board: Array(8).fill(null).map(() => Array(8).fill(null)),
            turn: 'white',
            mana: { white: 30, black: 30 },
            selected: null,
            validMoves: [],
            activePower: null,
            isAILoading: false
        };

        async function init() {
            const user = await signIn();
            if (state.gameId !== 'local') {
                state.mode = 'pvp';
                setupMultiplayerListener();
            } else {
                resetBoard();
                render();
            }
        }

        async function signIn() {
            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                return (await auth.signInWithCustomToken(__initial_auth_token)).user;
            } else {
                return (await auth.signInAnonymously()).user;
            }
        }

        function setMode(mode) {
            if (mode === 'ai') {
                window.location.href = window.location.pathname;
            } else {
                const newId = Math.random().toString(36).substring(7);
                window.location.href = `${window.location.pathname}?game=${newId}`;
            }
        }

        function resetBoard() {
            state.board = Array(8).fill(null).map(() => Array(8).fill(null));
            for (let i = 0; i < 8; i++) {
                state.board[1][i] = { type: 'p', color: 'black' };
                state.board[6][i] = { type: 'p', color: 'white' };
            }
            const layout = ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'];
            for (let i = 0; i < 8; i++) {
                state.board[0][i] = { type: layout[i], color: 'black' };
                state.board[7][i] = { type: layout[i], color: 'white' };
            }
        }

        function setupMultiplayerListener() {
            document.getElementById('multiplayer-controls').classList.remove('hidden');
            document.getElementById('game-url').value = window.location.href;
            document.getElementById('mode-pvp').classList.add('bg-blue-800');
            document.getElementById('opp-name').textContent = "Awaiting Friend...";
            
            const docRef = db.doc(`artifacts/${appId}/public/data/games/${state.gameId}`);
            
            docRef.onSnapshot((doc) => {
                if (!doc.exists()) {
                    docRef.set({
                        board: JSON.stringify(state.board),
                        turn: 'white',
                        mana: state.mana,
                        players: [auth.currentUser.uid]
                    });
                    state.myColor = 'white';
                } else {
                    const data = doc.data();
                    state.board = JSON.parse(data.board);
                    state.turn = data.turn;
                    state.mana = data.mana;
                    
                    if (!data.players.includes(auth.currentUser.uid) && data.players.length < 2) {
                        data.players.push(auth.currentUser.uid);
                        docRef.update({ players: data.players });
                    }
                    
                    state.myColor = data.players[0] === auth.currentUser.uid ? 'white' : 'black';
                    document.getElementById('opp-name').textContent = data.players.length > 1 ? "Friend Online" : "Awaiting Friend...";
                }
                render();
            }, (err) => console.error(err));
        }

        function render() {
            const boardEl = document.getElementById('board');
            boardEl.innerHTML = '';
            
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const square = document.createElement('div');
                    square.className = `square ${(r + c) % 2 === 0 ? 'light' : 'dark'}`;
                    
                    if (state.selected && state.selected.r === r && state.selected.c === c) square.classList.add('selected');
                    if (state.validMoves.some(m => m.r === r && m.c === c)) square.classList.add('valid-move');

                    const piece = state.board[r][c];
                    if (piece) {
                        const el = document.createElement('span');
                        el.className = 'piece';
                        el.textContent = PIECES[piece.color][piece.type];
                        el.style.color = piece.color === 'white' ? '#fff' : '#000';
                        if (piece.color === 'white') el.style.filter = 'drop-shadow(0 2px 2px rgba(0,0,0,0.3))';
                        square.appendChild(el);
                    }

                    square.onclick = () => handleSquareClick(r, c);
                    boardEl.appendChild(square);
                }
            }

            // Stats Update
            document.getElementById('mana-white-fill').style.width = state.mana.white + '%';
            document.getElementById('mana-black-fill').style.width = state.mana.black + '%';
            document.getElementById('player-mana-text').textContent = state.mana.white + ' MP';
            document.getElementById('opp-mana-text').textContent = state.mana.black + ' MP';
            
            const turnInd = document.getElementById('turn-indicator');
            turnInd.textContent = state.turn === 'white' ? "White's Turn" : "Black's Turn";
            turnInd.style.background = state.turn === 'white' ? '#fff' : '#ef4444';
            turnInd.style.color = state.turn === 'white' ? '#000' : '#fff';

            // Power button logic
            const currentMana = state.mana[state.myColor];
            document.getElementById('btn-teleport').classList.toggle('disabled', currentMana < 20);
            document.getElementById('btn-freeze').classList.toggle('disabled', currentMana < 15);
            document.getElementById('btn-spawn').classList.toggle('disabled', currentMana < 40);
        }

        async function handleSquareClick(r, c) {
            if (state.mode === 'pvp' && state.turn !== state.myColor) return;
            if (state.mode === 'ai' && state.turn === 'black') return;

            const piece = state.board[r][c];

            if (state.activePower) {
                applyPower(r, c);
                return;
            }

            if (piece && piece.color === state.turn) {
                state.selected = { r, c };
                state.validMoves = getValidMoves(r, c);
                render();
            } else {
                const move = state.validMoves.find(m => m.r === r && m.c === c);
                if (move) {
                    executeMove(state.selected.r, state.selected.c, r, c);
                    state.selected = null;
                    state.validMoves = [];
                    state.turn = state.turn === 'white' ? 'black' : 'white';
                    state.mana[state.turn] = Math.min(100, state.mana[state.turn] + 5);
                    
                    syncGame();
                    
                    if (state.mode === 'ai' && state.turn === 'black') {
                        setTimeout(runAIMove, 1000);
                    }
                } else {
                    state.selected = null;
                    state.validMoves = [];
                    render();
                }
            }
        }

        function executeMove(fR, fC, tR, tC) {
            const moving = state.board[fR][fC];
            const target = state.board[tR][tC];
            if (target) {
                state.mana[state.turn] = Math.min(100, state.mana[state.turn] + 15);
                showToast(`Captured ${target.type}! +15 Mana`);
            }
            state.board[tR][tC] = moving;
            state.board[fR][fC] = null;
            if (moving.type === 'p' && (tR === 0 || tR === 7)) moving.type = 'q';
        }

        async function runAIMove() {
            if (state.isAILoading) return;
            state.isAILoading = true;
            
            const prompt = `You are a Chaos Chess AI. Here is the current board: ${JSON.stringify(state.board)}. 
            You are playing BLACK. You have ${state.mana.black} Mana. 
            Choose a move or a Power (teleport: 20, freeze: 15, queen: 40).
            Respond ONLY with a JSON object: {"type": "move", "from": [r,c], "to": [r,c]} OR {"type": "power", "name": "teleport", "target": [r,c], "dest": [r,c]}.`;

            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                });
                const res = await response.json();
                const aiAction = JSON.parse(res.candidates[0].content.parts[0].text);
                
                if (aiAction.type === 'move') {
                    executeMove(aiAction.from[0], aiAction.from[1], aiAction.to[0], aiAction.to[1]);
                } else {
                    showToast("AI Used " + aiAction.name);
                    // Simplify: AI just moves or captures
                    executeMove(aiAction.target[0], aiAction.target[1], aiAction.dest[0], aiAction.dest[1]);
                }
                
                state.turn = 'white';
                state.mana.white = Math.min(100, state.mana.white + 5);
                state.isAILoading = false;
                render();
            } catch (e) {
                // Fallback: Random move if AI fails
                const blackPieces = [];
                state.board.forEach((row, r) => row.forEach((p, c) => { if(p && p.color === 'black') blackPieces.push({r,c}) }));
                const p = blackPieces[Math.floor(Math.random()*blackPieces.length)];
                const moves = getValidMoves(p.r, p.c);
                if (moves.length > 0) {
                    const m = moves[Math.floor(Math.random()*moves.length)];
                    executeMove(p.r, p.c, m.r, m.c);
                }
                state.turn = 'white';
                state.mana.white = Math.min(100, state.mana.white + 5);
                state.isAILoading = false;
                render();
            }
        }

        function getValidMoves(r, c) {
            const p = state.board[r][c];
            if (!p) return [];
            const moves = [];
            const d = {
                'p': p.color === 'white' ? [[-1, 0]] : [[1, 0]],
                'r': [[1,0],[-1,0],[0,1],[0,-1]],
                'n': [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]],
                'b': [[1,1],[1,-1],[-1,1],[-1,-1]],
                'q': [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]],
                'k': [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]]
            };
            
            if (p.type === 'p') {
                d.p.forEach(dir => { if (isValid(r+dir[0], c+dir[1]) && !state.board[r+dir[0]][c+dir[1]]) moves.push({r: r+dir[0], c: c+dir[1]}) });
                const cap = p.color === 'white' ? [[-1,-1],[-1,1]] : [[1,-1],[1,1]];
                cap.forEach(dir => { 
                    const nr=r+dir[0], nc=c+dir[1];
                    if (isValid(nr, nc) && state.board[nr][nc] && state.board[nr][nc].color !== p.color) moves.push({r: nr, c: nc});
                });
            } else if (['n','k'].includes(p.type)) {
                d[p.type].forEach(dir => {
                    const nr=r+dir[0], nc=c+dir[1];
                    if (isValid(nr, nc) && (!state.board[nr][nc] || state.board[nr][nc].color !== p.color)) moves.push({r: nr, c: nc});
                });
            } else {
                d[p.type].forEach(dir => {
                    for(let i=1; i<8; i++){
                        const nr=r+dir[0]*i, nc=c+dir[1]*i;
                        if (!isValid(nr, nc)) break;
                        const target = state.board[nr][nc];
                        if (!target) moves.push({r: nr, c: nc});
                        else { if(target.color !== p.color) moves.push({r: nr, c: nc}); break; }
                    }
                });
            }
            return moves;
        }

        function isValid(r, c) { return r>=0 && r<8 && c>=0 && c<8; }

        function activatePower(type) {
            const cost = { teleport: 20, freeze: 15, spawn: 40 }[type];
            if (state.mana[state.myColor] < cost) return;
            state.activePower = state.activePower === type ? null : type;
            showToast(state.activePower ? `Select Target for ${type}` : "Canceled Power");
            render();
        }

        function applyPower(r, c) {
            const p = state.activePower;
            const piece = state.board[r][c];
            if (p === 'teleport') {
                if (!state.selected) {
                    if (piece && piece.color === state.myColor) state.selected = {r, c};
                } else if (!piece) {
                    state.board[r][c] = state.board[state.selected.r][state.selected.c];
                    state.board[state.selected.r][state.selected.c] = null;
                    completePower(20);
                }
            } else if (p === 'freeze') {
                if (piece && piece.color !== state.myColor) {
                    showToast("Piece Frozen!"); // In this simple version, freeze just consumes mana for now
                    completePower(15);
                }
            } else if (p === 'spawn') {
                if (piece && piece.color === state.myColor && piece.type === 'p') {
                    piece.type = 'q';
                    completePower(40);
                }
            }
        }

        function completePower(cost) {
            state.mana[state.myColor] -= cost;
            state.activePower = null;
            state.selected = null;
            syncGame();
            render();
        }

        function syncGame() {
            if (state.mode === 'pvp') {
                db.doc(`artifacts/${appId}/public/data/games/${state.gameId}`).update({
                    board: JSON.stringify(state.board),
                    turn: state.turn,
                    mana: state.mana
                });
            } else {
                render();
            }
        }

        function showToast(msg) {
            const t = document.getElementById('toast');
            t.textContent = msg;
            t.style.opacity = '1';
            setTimeout(() => t.style.opacity = '0', 2000);
        }

        function copyURL() {
            const el = document.getElementById('game-url');
            el.select();
            document.execCommand('copy');
            showToast("Link Copied!");
        }

        window.onload = init;
    </script>
</body>
</html>
